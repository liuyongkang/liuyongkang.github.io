---
layout: post
title: 数据压缩之编码器
decription:
category: blog
tag: ['编码', '压缩', 'huffman', '算术编码']
---


# 数据压缩之编码器


##前言

这一章主要来讲编码器。编码器是一种将信息一种特定格式转换为其他特定格式的算法。当然除了编码器还需要解码器，它会将编码后的数据转换为原数据。

本文主要会讲两个常用的编码，一个是很多人比较熟悉的huffman编码，另一个是算术编码。

##huffman编码

huffman编码是一种最优前缀编码，那么前缀码又是什么呢？

一个字符的编码不是另一个字符编码的前缀，这样的编码就是前缀码，而最优前缀编码就是，编码出的长度最短。

###huffman树

生成huffman编码的过程需要建立一颗huffman树

直接来看一个例子吧，现有如下数据（加空格只是为了看起来方便）：

        abac deaf abea ceba caba feac aaca cb

统计频数如下：

![频数统计结果](/images/数据压缩之编码器/table1.png)

现在开始建树，先从从表中找出两个频数最小的元素，把较大的放左边，较小的放右边，然后把它们的频数加起来，合为一个元素：

![第一步](/images/数据压缩之编码器/table2.png)

新生成的元素与其他同等对待，再次选出两个：

![第二步](/images/数据压缩之编码器/table3.png)

重复上述步骤，直到只剩一个元素，这时树就建立好了

![第三步](/images/数据压缩之编码器/table4.png)
![第四步](/images/数据压缩之编码器/table5.png)
![最后一步](/images/数据压缩之编码器/table6.png)

###生成编码

下一步要根据哈夫曼树得到huffman编码，从huffman树的树根到每个字符的路径就可以作为这个字符的编码。

就以上面的huffman树来举例，假设左代表“0”，右代表“1”，那么我们就可以得到a的编码为“1”，b的编码为“00”

可以得到编码表：

![huffman编码](/images/数据压缩之编码器/huffman_code.png)

将前面的数据编码后的结果就是

        1001 1000 0111 0101 
        0110 1001 0101 0000
        1000 1100 0100 1101 
        1001 0100 0110 0010 
        0000 1 

编码前数据为240bits，编码后只有69bits，看起来效果还不错哦

###范式huffman编码

但在实际使用中，朴素的huffman实现效率很差，后来出现了一个huffman的改进算法，叫做范式huffman编码，实现起来比huffman会好很多。

引用一个很了解底层的牛人原话：

HUFFMAN主要有两个问题，一是需要扫描两遍输入数据，二是树状结构编解码慢。对于第一个问题，基于统计信息的熵编码都很难解决这个问题，可以设计成自适应的，根据统计数据不停地改变调整码树，这会比较麻烦。对于第二个问题，这跟硬件有关系，二叉树的编码、解码都是O(1)的，复杂度上不能更优了，但是计算机硬件的特性，会使得树状结构遍历过程中CACHE MISS比较严重，如果码树比较小的话，可以都放在一级CACHE，性能会好很多，但是编码、解码一般都只是模块流程的一部分，所以码树经常会挤出CACHE，就算留在CACHE里，树状结构if else也会造成分枝预测错误，导致流水线中断。

原文地址：http://hi.baidu.com/rodimus/item/3f61e235646950d66c15e9ef

上面的两个问题中，第一个很难避免，这是由于huffman算法本身决定的，而第二个比较好解决，只要编码表，解码表存储合理，这个问题就能很好解决，先来讲讲范式huffman，然后再说这个问题该怎么解决。

范式huffman编码也是前缀编码，最后的效果与huffman相同，但是编码却与huffman不同。

范式可以理解为公认的模式，也就是说范式huffman对数据的编码只有一种结果，这一点不同于huffman，而且范式huffman的编码结果是huffman无法得到的。

再次使用上面的例子来进行说明：

####编码长度

与huffman不同，范式huffman的第一步是求出每个字符的编码长度，但求解过程与huffman相似。这里采用bzip2的实现来讲解（使用bzip2的思想，实现并不完全相同），下面的图中省略了字符，只留下字符出现的频数

如果数据中出现过的字符的数量为n，那么就使用一个长度为2n的数组，后面n个元素为个字符的频数，前面n个元素为以后面频数建立的最小堆，堆中的数据为索引，如下，分隔线之前为最小堆：

![](/images/数据压缩之编码器/heap1.png)

取出堆顶元素9，它代表索引为9的元素是最小的，即在频数中1是最小的，将9放到堆尾，调整堆，使它再次成为最小堆：

![](/images/数据压缩之编码器/heap2.png)

再取出堆顶元素，调整为最小堆：

![](/images/数据压缩之编码器/heap3.png)

这时将取出的两个元素对应的频数相加，即1 + 2 = 3，将其放入下标为5的位置，将下标为9和11内的元素改为5，表示它们的父亲为5，将下标为4的元素改为5，并将其插入堆中，如下：

![](/images/数据压缩之编码器/heap4.png)

上面的三个过程就是，取出两个最小值，再将他们的和和并为一个节点。
再来详细列出下一组操作：
![](/images/数据压缩之编码器/heap5.png)
![](/images/数据压缩之编码器/heap6.png)
![](/images/数据压缩之编码器/heap7.png)

重复上述操作，下面只列出每一步的结果：

![](/images/数据压缩之编码器/heap8.png)
![](/images/数据压缩之编码器/heap9.png)
![](/images/数据压缩之编码器/heap10.png)

到这里huffman树也就建立好了，其实这算是一个很特殊的树，因为无法遍历它，但是对于我们来说，这些信息已经足够求出编码长度了。
从树的叶子节点到树根的距离就是对应字符的编码长度，在这里树根为1，以叶子节点7为例，它的父亲节点为3，3的父亲节点为2，2的父亲节点为1，叶子节点对应的字符为b，那么b的编码长度就为3，按照这个方法，可以求出所以字符的编码:

![](/images/数据压缩之编码器/code.png)

####生成编码

先把最后生成的编码列出来在慢慢讲解：

![](/images/数据压缩之编码器/code2.png)


##算术编码



##后记
