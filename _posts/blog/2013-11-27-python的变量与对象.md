---
layout: post
title: python的变量与对象
description: 在学习python的过程中，发现python中的变量与对象跟我见过的语言都不太相同，有很多地方容易出错，在此详细记录一下
category: blog
---

##适合人群

这篇博文适合于初学python的人看，如果你是一个pythoner，却没有仔细考虑过这个问题，那么本文也很适合你。


##前言

最近在看python，作为一门脚本语言，它确实很强大，用起来也很方便。
以前也看过一点点python，但是了解不够深入，这次想认真学一学。
python的语法并不复杂，但是在学习中还是发现了一些让人头疼的东西，就是变量与对象的关系。
与一般的面向对象，面向过程语言不同，python的变量不需要声明，类型可变，这是其使用方便的一个原因，但是，也带来了很大的问题。
现在我就来说说python中变量与对象的“坑”。

注：本文讲述python3.x中的内置类型，博主初学python，如果有错误，还望指正


##python的类型

这里并不会一一列举出所有的内置类型，容易出错的讲讲就可以了。

在之前接触到的语言中，一个变量的对象就是属于该变量的，而python不同，由于它的变量并不具有类型，所以变量与对象也就无法绑定到一起。
实际上，只有对象才具有类型，python使用了引用的方法，来指明一个变量所对应的对象，下面讲述几个常见类型。

###int

python中的int对象是不可变的。
如果一块空间中的对象是int类型的，那么它就不可改变，如果你对一个int变量又进行一次赋值，那么它所对应的对象的地址就会发生变化。
看看下面的例子，id是python的一个内置函数,它的返回值是对象的一个标号（并不是对象的地址，只是可以唯一标识该对象的一个数字）

	>>> i = 1
	>>> id(i)
	140372742502976
	>>> i = 2
	>>> id(i)
	140372742503008

我们发现给i赋值为2后，该变量所对应的对象发生了改变，这不仅仅是简单的把那个地址上的对象换掉，而是指向了另外一块空间，来表示该变量所对应的对象，简单的原理图如下：

![单个变量的对象图示](/images/python的变量与对象/int.png)

如果还不够理解，那就再来看一个例子：


	>>> ia = 1
	>>> id(ia)
	140372742502976
	>>> ib = ia
	>>> id(ib)
	140372742502976
	>>> ib = 2
	>>> id(ib)
	140372742503008

在把ia赋值给ib后，我们发现，它们的对象是同一个。
又一次给ib赋值后，int对象是不可变的，所以ib对应的对象的地址不再是原来的那个，再看看下面的原理图就会清楚很多。

![两个变量的对象图示](/images/python的变量与对象/intab.png)

说句题外话，如果你观察足够仔细，那么你会发现，在这两个小例子中值为1的对象和值为2的对象的地址都没有发生改变，原因是python的实现可能是考虑到了效率问题，[官方文档][1]指出，在-5~256之间的整数的地址不会发生变化，那么id值也就不会变。

###str

字符串类型的对象也是不可变的，而且对某一个字符进行修改还是出错，如下：

	>>> s = 'hello'
	>>> id(s)
	140372715358056
	>>> s = 'world'
	>>> id(s)
	140372715358168
	>>> s[0] = 'h'
	Traceback (most recent call last):
	  File "<stdin>", line 1, in <module>
	TypeError: 'str' object does not support item assignment

原理与int类型基本相同，也就不再画了。

###list

列表与链表相似，一个list中可以有很多元素，并且每个元素的类型也不必相同，与前面两个类型不同，list是一个可变类型。
一个例子：

	>>> l = [1, 2, 4]
	>>> l
	[1, 2, 4]
	>>> id(l)
	140372742882584
	>>> id(l[1])
	140372742503008
	>>>
	>>>
	>>> l[1] = 3
	>>> l
	[1, 3, 4]
	>>> id(l)
	140372742882584
	>>> id(l[1])
	140372742503040

list中一个元素改变后，整个list对象的地址并不改变，只是有变化的元素的地址发生了改变，原理图如下：

![list类型](/images/python的变量与对象/list.png)

##变量的拷贝

我们已经知道了，对变量直接赋值只是生成一个引用，并不是真正的拷贝，那么list和dict类型该如何拷贝呢，其实很简单：

	>>> la = [1, 2, 3]
	>>> id(la)
	140372715504416
	>>> lb = la[:]
	>>> id(lb)
	140372707721016
	>>> la == lb
	True
	>>>
	>>>
	>>> da = {1:2, 3:4}
	>>> id(da)
	140372743029824
	>>> db = da.copy()
	>>> id(db)
	140372715385632
	>>> da == db
	True

但是这样就真的可以了吗，如果list中的元素还是一个list，那么会出现什么情况呢，看下面：


	>>> la = [1, [2, 3], 4]
	>>> lb = la[:]
	>>> la == lb
	True
	>>> lb[1][0] = 3
	>>> lb
	[1, [3, 3], 4]
	>>> la == lb
	True

其实这只是一个浅层的拷贝，只是把原来的list直接复制了过来，并没有关心里面还没有list，所以导致了错误。
这一步的图示：

![浅拷贝](/images/python的变量与对象/shallowcopy.png)

那么拷贝list就很容易了，就是进行一个逐层向下的拷贝，可是自己实现起来又很不方便，标准库给我们提供了方法，使用如下：


	>>> import copy
	>>> la = [1, [2, 3], 4]
	>>> lb = copy.copy(la)
	>>> lc = copy.deepcopy(la)
	>>> la == lb == lc
	True
	>>> lb[1][0] = 1
	>>> lc[1][0] = 1
	>>> la
	[1, [1, 3], 4]

最终的图示：

![深拷贝](/images/python的变量与对象/deepcopy.png)

##结语
其实在python中，变量与对象的关系也没有那么复杂，它这样设计虽然看起来有一点不科学，但是它真的很好用，值的学一学。

[1]: http://docs.python.org/2/c-api/int.html#PyInt_FromLong "python的官方文档"
